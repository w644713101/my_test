/*
数据范围
0<N≤1000
0<V≤2000
0<vi,wi,si≤2000

不能用O(n3)做
多重背包的二进制优化方法。

这个优化方法就是把带有数量的 物品，平铺成01背包
关键的是平铺什么样的数，才会在平铺出来的数量 最后不会超过规定的时间，
如果全都平铺成1当然可以，但是那样最后 会超时

*/
// 采用二进制平铺
for (int i = 0; i < n ; i ++)
{
    int v, w, s;
    cin >> v >> w >>  s;
    for (int k = 1; k <= s; k *= 2)
    {
        s -= k;
        goods.push_back({v * s, w * s});
    }
    if (s > 0) goods.push_back({v * s, w * s})  // 减完二进制的余数
}
